<!DOCTYPE html>
<html>
  <head>
    <title>Regular Expressions</title>
    <meta charset="utf-8">
    <link href="libs/remark-css-0.0.1/example.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Regular Expressions
## (Slides by Heike Hofmann)

---




## Regular Expressions 

&lt;img src="images/email.png" class="cover" width=1800&gt;

---

## [xkcd #208](https://xkcd.com/208/)

![](https://imgs.xkcd.com/comics/regular_expressions.png)

---

## Regular Expressions

- Regular expressions (regex, regexp) is a sequence of characters that form a search pattern

- Originated in 1950s. American mathematician Stephen Kleene formalized the description of a regular language.

-  Common usage with Unix text processing utilities ed, an editor, and grep (global regular expression print), a filter.

- R language provides this capability through `grep`, `gsub`, ...

---

## Example: 


```r
# http://heike.github.io/rwrks/01-r-intro/data/meta.txt")
meta &lt;- read.table("../data/meta.txt")
```

---

## Example

---

## Basics of regular expressions

| expression          | meaning          |
----------------------------|:---------------------------- |
| ordinary characters | match themselves |
|  `$ ^ { [ ( ) ] } * + ? \`      |   special characters    |
| `[abc]` | matches single letter from "a", "b", or "c" |
| `[^abc]` | matches any single letter other than "a", "b", and "c" |
| `[a-gm]` | matches any single letter out of "a", "b", ... "g" or "m" |
| `[a-z][0-9]`   | matches one lower case letter followed by a digit|

---

## Basics of regular expressions (cont'd)

| expression          | meaning          |
----------------------------|:---------------------------- |
| `\x` | match a hexadecimal number |
| `\s` | whitespace |
| ^ | starting position within the string |
| $ | ending position with in the string |
| `&lt; &gt;` | start, end of a word |
| `\t \r \v \n` | tab, carriage return, vertical tab, new line |

---
## Multipliers

- `?` indicates there is **zero or one** of the preceding element, eg `colou?r` matches "color" or "colour"

- `*` indicates there is **zero or more** of the preceding element, eg `ab*c` matches "ac", "abc", "abbc", "abbbc", ...

- `+` indicates there is **one or more** of the preceding element, eg `ab+c` matches "abc", "abbc", "abbbc", ...

- `.` matches any **single** character, eg `a.c` matches "abc" or "atc"

---
## Advanced Patterns

see `?regex`

* `[:alpha:]` Any alphabetic character

* `[:lower:]` Any lowercase character

* `[:upper:]` Any uppercase character

* `[:digit:]` Any digit

* `[:alnum:]` Any alphanumeric character (alphabetic or digit)

* `[:blank:]` Any white space character (space, tab, vertical tab)

* `[:graph:]` Any printable character, except space

* `[:print:]` Any printable character, including the space

* `[:punct:]` Any punctuation (i.e., a printable character that is not white space or alphanumeric)

* `[:cntrl:]` Any nonprintable character

---

## Examples

What do these regular expressions do?

`.at`

`[hc]at`

`[^t]at`

`[^hc]at`

`^[S]tat`

`[S]tat$`


---

## Trickier Examples

What do these regular expressions do?

`^s.*`

`[A-Z]\{3,\}`

`\[.\]`

`[bB]ar ?[cC]hart`

`^[0-9]{5}$`

`^(\d{3}-\d{3}-\d{4})*$`

`(\w[-._\w]*\w@\w[-._\w]*\w\.\w{2,3})`

---
class: inverse

## Your Turn (5 min)

- write out the regular expression for a number in scientific notation

&lt;!--
```
grep("[+-]?([0-9]+\\.)?[0-9]+[eE][+-]?[0-9]+", c("1e-4", "-2.13e-1", "2E4"))
```
--&gt;

- how can we try out whether the pattern works?


---

## Regular expressions in R

Patterns &amp; Matches

* Find pattern: &lt;code&gt;grep, regexpr, gregexpr&lt;/code&gt;

* Pattern replacement: &lt;code&gt;gsub (pattern, replacement, x)&lt;/code&gt;

```
grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,
     fixed = FALSE, useBytes = FALSE, invert = FALSE)

gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
     fixed = FALSE, useBytes = FALSE)
```

---
class: inverse

## Your Turn (8 min)


---
class: inverse

## Your Turn - Solution


---

## Extracting pieces from a regular expression

- parentheses `( )` group a pattern of interest together

- using `\\1`, `\\2`, `\\3`, ... we can extract the first, second, third ... pattern

Imagine, we want to extract the day number for each row


```r
head(meta)
```

```
##   label      Group numOtus
## 1  0.03 FS1EP1ABD0    5802
## 2  0.03 FS1EP1ABD1    5802
## 3  0.03 FS1EP1AD11    5802
## 4  0.03  FS1EP1AD4    5802
## 5  0.03 FS1EP1BD11    5802
## 6  0.03  FS1EP1BD4    5802
```

We use the expression `D` as cue; the number after that is the day:


```r
gsub('.*D([:digit:]*)','\\1', meta$Group)
```

```
##   [1] "0"  "1"  "11" "4"  "11" "4"  "0"  "1"  "11" "4"  "7"  "11" "4"  "7" 
##  [15] "0"  "1"  "11" "4"  "7"  "11" "4"  "7"  "4"  "4"  "1"  "1"  "4"  "0" 
##  [29] "4"  "4"  "4"  "0"  "4"  "4"  "4"  "0"  "4"  "4"  "4"  "0"  "4"  "4" 
##  [43] "4"  "0"  "4"  "4"  "4"  "0"  "4"  "4"  "4"  "0"  "4"  "4"  "4"  "0" 
##  [57] "4"  "4"  "4"  "0"  "4"  "4"  "4"  "4"  "4"  "4"  "0"  "4"  "4"  "4" 
##  [71] "0"  "4"  "4"  "0"  "4"  "4"  "7"  "0"  "4"  "7"  "7"  "7"  "0"  "4" 
##  [85] "7"  "7"  "7"  "0"  "4"  "7"  "7"  "7"  "0"  "4"  "7"  "7"  "7"  "0" 
##  [99] "4"  "7"  "7"  "7"  "0"  "4"  "7"  "7"  "7"  "0"  "4"  "7"  "7"  "7" 
## [113] "0"  "4"  "7"  "7"  "4"  "0"  "4"  "4"  "7"  "0"  "4"  "7"  "7"  "7" 
## [127] "0"  "4"  "7"  "7"  "7"  "0"  "4"  "7"  "7"  "7"  "0"  "4"  "7"  "7" 
## [141] "7"  "0"  "4"  "7"  "7"  "7"  "0"  "4"  "7"  "7"  "7"  "0"  "4"  "7" 
## [155] "7"  "7"  "0"  "4"  "7"  "7"  "7"  "0"  "4"  "7"  "7"  "7"  "0"  "4" 
## [169] "7"  "7"  "4"  "0"  "4"  "4"  "7"  "0"  "4"  "7"  "7"  "7"  "0"  "4" 
## [183] "7"  "7"  "7"  "0"  "4"  "7"  "7"  "14" "0"  "11" "14" "4"  "7"  "14"
## [197] "14" "0"  "11" "14" "4"  "7"  "14" "14" "0"  "11" "14" "4"  "7"  "14"
## [211] "14" "0"  "11" "14" "4"  "7"  "14" "14" "0"  "11" "14" "4"  "7"  "14"
## [225] "14" "0"  "11" "14" "4"  "7"  "14" "14" "0"  "11" "14" "4"  "7"  "14"
## [239] "4"  "0"  "4"  "4"  "4"  "0"  "4"  "4"  "14" "0"  "11" "14" "4"  "7" 
## [253] "14" "14" "0"  "11" "14" "4"  "7"  "14" "14" "11" "14" "4"  "7"  "14"
## [267] "14" "0"  "11" "14" "4"  "7"  "14" "14" "0"  "11" "14" "7"  "14" "14"
## [281] "0"  "11" "14" "4"  "7"  "14" "14" "0"  "11" "14" "4"  "7"  "14" "14"
## [295] "11" "14" "4"  "7"  "14" "14" "0"  "11" "14" "4"  "7"  "14" "14" "0" 
## [309] "11" "14" "4"  "7"  "14" "14" "0"  "11" "14" "4"  "7"  "14" "14" "0" 
## [323] "11" "14" "4"  "7"  "14" "14" "0"  "11" "14" "4"  "7"  "14" "14" "0" 
## [337] "11" "14" "4"  "7"  "14" "14" "0"  "11" "14" "4"  "7"  "14" "14" "0" 
## [351] "11" "14" "4"  "7"  "14" "4"  "0"  "4"  "4"  "4"  "4"  "4"  "4"  "0" 
## [365] "4"  "4"  "4"  "4"  "4"  "33" "33" "33" "33" "33" "33" "33"
```


---
class: inverse

## Your Turn (5 min)
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {window.dispatchEvent(new Event('resize'));});
(function() {var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler"); if (!r) return; s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }"; d.head.appendChild(s);})();</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
});
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
