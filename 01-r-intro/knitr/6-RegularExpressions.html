<!DOCTYPE html>
<html>
  <head>
    <title>Regular Expressions</title>
    <meta charset="utf-8">
    <link href="libs/remark-css-0.0.1/example.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Regular Expressions
## (Slides by Heike Hofmann)

---




## Regular Expressions 

&lt;img src="images/email.png" class="cover" width=1800&gt;

---

## [xkcd #208](https://xkcd.com/208/)

![](https://imgs.xkcd.com/comics/regular_expressions.png)

---

## Regular Expressions

- Regular expressions (regex, regexp) is a sequence of characters that form a search pattern
- Originated in 1950s. American mathematician Stephen Kleene formalized the description of a regular language.
-  Common usage with Unix text processing utilities ed, an editor, and grep (global regular expression print), a filter.
- R language provides this capability through `grep`, `gsub`, ...

---

## Example: 


---

## Example

---

## Basics of regular expressions

| expression          | meaning          |
----------------------------|:---------------------------- |
| ordinary characters | match themselves |
|  `$ ^ { [ ( ) ] } * + ? \`      |   special characters    |
| `[abc]` | matches single letter from "a", "b", or "c" |
| `[^abc]` | matches any single letter other than "a", "b", and "c" |
| `[a-gm]` | matches any single letter out of "a", "b", ... "g" or "m" |
| `[a-z][0-9]`   | matches one lower case letter followed by a digit|

---

## Basics of regular expressions (cont'd)

| expression          | meaning          |
----------------------------|:---------------------------- |
| `\x` | match a hexadecimal number |
| `\s` | whitespace |
| ^ | starting position within the string |
| $ | ending position with in the string |
| `&lt; &gt;` | start, end of a word |
| `\t \r \v \n` | tab, carriage return, vertical tab, new line |

---
## Multipliers

- `?` indicates there is **zero or one** of the preceding element, eg `colou?r` matches "color" or "colour"
- `*` indicates there is **zero or more** of the preceding element, eg `ab*c` matches "ac", "abc", "abbc", "abbbc", ...
- `+` indicates there is **one or more** of the preceding element, eg `ab+c` matches "abc", "abbc", "abbbc", ...
- `.` matches any **single** character, eg `a.c` matches "abc" or "atc"

---
## Advanced Patterns

see `?regex`

* `[:alpha:]` Any alphabetic character
* `[:lower:]` Any lowercase character
* `[:upper:]` Any uppercase character
* `[:digit:]` Any digit
* `[:alnum:]` Any alphanumeric character (alphabetic or digit)
* `[:blank:]` Any white space character (space, tab, vertical tab)
* `[:graph:]` Any printable character, except space
* `[:print:]` Any printable character, including the space
* `[:punct:]` Any punctuation (i.e., a printable character that is not white space or alphanumeric)
* `[:cntrl:]` Any nonprintable character

---

## Examples

What do these regular expressions do?

`.at`

`[hc]at`

`[^t]at`

`[^hc]at`

`^[S]tat`

`[S]tat$`


---

## Trickier Examples

What do these regular expressions do?

`^s.*`

`[A-Z]\{3,\}`

`\[.\]`

`[bB]ar ?[cC]hart`

`^[0-9]{5}$`

`^(\d{3}-\d{3}-\d{4})*$`

`(\w[-._\w]*\w@\w[-._\w]*\w\.\w{2,3})`

---
class: inverse

## Your Turn (5 min)

- write out the regular expression for a number in scientific notation
&lt;!--
```
grep("[+-]?([0-9]+\\.)?[0-9]+[eE][+-]?[0-9]+", c("1e-4", "-2.13e-1", "2E4"))
```
--&gt;
- how can we try out whether the pattern works?


---

## Regular expressions in R

Patterns &amp; Matches

* Find pattern: &lt;code&gt;grep, regexpr, gregexpr&lt;/code&gt;
* Pattern replacement: &lt;code&gt;gsub (pattern, replacement, x)&lt;/code&gt;

```
grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,
     fixed = FALSE, useBytes = FALSE, invert = FALSE)

gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
     fixed = FALSE, useBytes = FALSE)
```

---
class: inverse

## Your Turn (8 min)


---
class: inverse

## Your Turn - Solution


---

## Extracting pieces from a regular expression

- parentheses `( )` group a pattern of interest together
- using `\\1`, `\\2`, `\\3`, ... we can extract the first, second, third ... pattern

Imagine, we want to extract the number of credits for each course


```r
#credits[1:5]
```

We use the expression `Cr. ` as cue; the number after that is the number of credits:

```r
#gsub(".*Cr\\. ([0-9]|R|(arr)).*", "\\1", credits)
```


---
class: inverse

## Your Turn (5 min)
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {window.dispatchEvent(new Event('resize'));});
(function() {var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler"); if (!r) return; s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }"; d.head.appendChild(s);})();</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
});
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
